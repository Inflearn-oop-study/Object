# 12장 다형성

이 장에서는 다형성을 구현하는 **상속**의 메커니즘에 대해 이야기 하는장이다.

## 상속의 양면성

객체지향 프로그래밍 에서는 `데이터`와 `행동`이라는 두가지 관점을 함께 고려해야 한다.

또한 상속의 메커니즘을 이해하기 위해선 다음과 같은 개념에 대한 이해가 필요하다.

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조

📌 **상속에서 메서드 오버라이딩 vs 메서드 오버로딩**

- 메서드 오버라이딩: 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것
- 메서드 오버로딩: 부모클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것

📌 **데이터 관점 상속, 행동 관점 상속**

- 데이터 관점 상속: 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함
- 행동 관점 상속: 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함

## 업케스팅, 동적바인딩

- 자식클래스는 부모클래스를 대체할 수 있다. 이것을 **업케스팅** 이라고 한다.
- 이러한 업케스팅을 이용해 확장에 용이한 설계를 할 수 있다.
- 정적타입언어에선 컴파일시점에 호출된 함수가 결정되며, 이 방식을 정적 바인딩이라고 한다.
- 반면 객체지향 언어에선 런타임에 실행될 메서드가 결정되며, 이를 동적 바인딩 이라고 한다.

객체지향 시스템에선 실행될 메서드를 어떻게 결정하는가? 를 이야기 하다보면 **self**변수에 대한 이해가 필요하다.

> C++, 자바, C#에선 self참조를 this라고 부른다.

self참조는 임시 변수이며, 메시지를 수신한 객체를 가리키게 된다.

## 동적 메서드 탐색과 다형성

동적 메서드 탐색은 두가지 원리로 구성된다.

- 자동적 메시지 위임: 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상위 클래스에 처리를 **위임**한다.
- 동적인 문맥: 메시지를 수신했을 때 실제로 어떤 메시지를 실행할지 결정하는 것은 런타임에 이루어지며, 메서드 탐색은 self참조를 이용해 결정한다.

### super vs self

- self참조의 특징은 동적이라는 점이고, self참조는 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정한다.
- super는 항상 부모클래스에서부터 탐색을 시작한다. super는 컴파일시점에 미리 결정할 수 있다.

## 상속 vs 위임

위임은 self참조가 자동으로 전달된다. 이로써 자식 클래스의 인스턴스와 부모 클래스의 인스턴스 사이에 실행 문맥을 공유할 수 있게 해준다.

클래스가 없는 객체지향 언어 (프로토타입 기반의 자바스크립트) 에서도 위임을 이용해  상속관계를 표현한다.

# 13장 서브클래싱과 서브타이핑

상속은 두가지 용도로 사용된다.

- 타입계층 관점에서 부모 클래스는 자식 클래스의 일반화, 자식 클래스는 부모 클래스의 특수화 이다.
- 코드 재사용 관점에선 상속을 선언함으로서 부모 클래스의 코드를 재사용할 수 있다.

그러나 상속의 목표는 코드 재사용이 아닌 타입계층을 구현하는 것이어야 한다. 올바른 타입 곛으을 구성하는 방법은 무엇인가?

## 타입

1. 개념 관점 타입: 심볼, 내연, 외연 세가지 요소로 구성된다. 개념적으로 우리가 인지하는 객체들에 적용하는 개념이나 아이디어를 가리킨다.
2. 프로그래밍 언어 관점 타입: 비트 묶음에 의미를 부여하기 위해 사용된다. 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고, 개발자의 실수를 방지한다.
3. 객체지향 관점 타입: **타입 정의 == 객체의 퍼블릭 인터페이스 정의**

## 타입 계층

📌 일반화 vs 특수화
- 일반화: 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과
- 특수화: 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과

📌 슈퍼타입 vs 서브타입
- 슈퍼타입: 서브타입이 정의한 퍼블릭 인터페이스를 **일반화**
- 서브타입: 슈퍼타입이 정의한 퍼블릭 인터페이스를 **특수화**

> 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주된다.

## 서브클래싱과 서브타이핑

📌 마틴 오더스키가 제안한 상속을 사용해야 하는 경우:

- 상속 관계가 is-a 관계를 나타낼때
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방할때

📌 is-a 관계와 행동 호환성

펭귄과 새의 관계의 예시에서 볼때, 상속을 is-a 관계라고 표현할 때 혼란을 야기할 수 있다.<br/>
이보단 **행동 호환성**이 더 중요하다.

행동 호환성이란, 클라이언트 관점에서 두 타입이 동일하게 행동할것인지 기대하는지에 따라 타입계층을 결정하는 것이다.

> 자연어에 현혹되지 않고, 클라이언트가 기대하는 행동에 초점을 맞추어 설계하는것이 옳다.

## 서브 클래싱 vs 서브 타이핑

- 서브 클래싱: 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
  - 자식 인스턴스가 부모 인스턴스를 대체할 수 없다.
  - == 구현 상속, 클래스 상속
- 서브 타이핑: 타입 계층을 구성하기 위해 상속을 사용하는 경우
  - 자식 인스턴스가 부모 인스턴스를 대체할 수 있다.
  - == 인터페이스 상속
 
## 리스코프 치환 원칙

> 서브타입은 그것의 기반타입에 대해 대체 가능해야 한다.

리스코프 치환 원칙을 따르는 설계는 유연할 뿐만 아니라 확장성이 높다.
OCP와 DIP는 리스코프 치환 원칙을 전제로 한다.

# 느낀점

상속이 어떻게 구현되는지, 또 상속을 사용해야하는 경우는 어떤 경우인지 공부했다.
코드를 재사용하기 위해서 추상클래스를 사용하곤 했는데.. 이러한 이유로 사용하는것은 지양하고 더 좋은 설계를 고민해야겠다는 생각을 했다.
교과서에서 is-a로 상속을 설명하곤 했는데 이보단 행동 호환성이라는 단어를 머리에 새겨야 겠다.

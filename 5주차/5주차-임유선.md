# 8장

**📌 컴파일 의존성과 런타임 의존성**

코드 구조는 컴파일 시점에 확정되나, 프로그램 실행시 런타임에 의존성이 결정되는 경우가 있다. **추상화**를 한 경우가 그러하다.
컴파일 시점에는 전혀 관계 없던 클래스가 런타임에 의존관계를 맺게 된다.

이렇게 컴파일타임 구조와 런타임 구조는 거리가 멀 수 있고, 거리가 멀수록 추상화가 잘 되었다고 할 수 있다. 

**📌 컨텍스트 독립성**

어떤 클래스가 실행되기 위해서 필요한 정보들을 **컨텍스트** 라고 한다. 컨텍스트에 대한 정보가 많을수록
재사용하기 힘들어진다. 유연한 설계를 위해선 컨텍스트 정보를 줄여, **컨텍스트 독립성**을 확보해야 한다.

> 한번 더 강조한다. 약한 결합도가 중요하다!

**📌 추상화에 의존하라**

1. 구체 클래스 의존성
2. 추상 클래스 의존성
3. 인터페이스 의존성

아래로 갈수록 결합도가 느슨해, 재사용성이 더 높다. 즉, 의존하는 대상이 추상적일수록 결합도가 느슨해진다.

# 9장

**📌 개방-폐쇄 원칙 (OCP)**

> 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.

How?

1. 추상화에 의존
- 컴파일타임 의존성을 고정시키고, 런타임 의존성을 변경

2. 생성 사용 분리
- 객체 생성에 특화된 `Factory`를 사용해, 객체의 생성과 사용을 분리한다.

**📌 도메인과 무관한 객체, PURE FABRICATION**

모든 책임을 도메인 객체에게 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제가 일어난다.

이를 해결하기 윈해서 도메인과 무관산 PURE FABRICATION(순수한 가공물) 과 같은 인공적인 객체가 필요하다.

위에서 생성 책임을 할당한 FACTORY 또한 PURE FABRICATION 이며, 대부분의 디자인 패턴도 이를 포함한다.

**📌 (DI) Dependency Injection, 의존성 주입**

객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후, 이를 전달해 의존성을 해결하는 것을 **의존성 주입(Dependency Injection)** 이라고 한다.

방법은 세가지가 있다.

- 생성자 주입
- setter 주입
- 메서드 주입

**📌 (DIP) Dependency Inversion Principle, 의존성 역전 원칙**

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

# 느낀점

핵심이 되는 단어가 많이 등장했던 장이였던 것 같다. 조금씩 다르게 표현하지만 결국엔 추상화가 중요하다는 내용이다.
이렇게까지 반복하는것을 보면, 정말 얼마나 추상화가 중요한것인지 깨닫게 되는 것 같다.
추상화가 중요하고 유연한 설계는 중요하지만 9장 끝부분의 이야기도 공감이 되었다.
지나친 유연성은 불필요한 복잡성을 낳는다. 그렇다. 필요없는 부분까지 추상화하여 코드를 더 파악하고 어렵게 만들 필요는 없다.
컴파일구조와 런타임구조가 다른것과, 추상화와는 관련지어 생각해본 적 없는데, 새로운 관점을 얻게된 것 같다.

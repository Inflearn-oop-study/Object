# 08. 의존성 관리하기

객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다.

# ✅ 의존성 이해하기

## 변경과 의존성

설계와 관련된 대부분의 용어들이 변경과 관련있듯이 의존성도 그렇다.

두 요소 사이의 의존성은의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다.

## 의존성 전이

의존성은 전이될 수 있다.

의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다.

- 집적 의존성 : 한 요소가 다른 요소에 직접 의존하는 경우를 가리킨다.
- 간접 의존성 : 직접적인 관계는 존재하지 않지만 의존성 전이에 의해 영향이 전파되는 경우를 가리킨다.

## 런타임 의존성과 컴파일 타임 의존성

컴파일 타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이다.

컴파일 타임 의존성을 런타임 으존성으로 대체해서 Movie클래스가 할인 정책을 구현한 두 클래스의 존재를 모르지만 실행지점에는 두 클래스의 인스턴스와 협력할 수 있게 된다.

**유연하고 재사용 가능한 설계를 창조하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.**

> 시스템의 실행 시점 구조는 언어가 아닌 설계자가 만든 타입들 간의 관련성으로 만들어진다.

## 컨텍스트 독립성

클래스는 자신과 협력할 객체의 구체적인 클래스를 알면 안된다.

구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합된다.

→ 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.

**컨텍스트 독립성** : 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.

## 의존성 해결하기

컴파일 타임 의존성을 실행 컨테스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.

**의존성을 해결하는 3가지 방법**

1. 객체를 생성하는 시점에 생성자를 통해 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
   1. 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다.
3. 메서드 실행 시 인자를 이용해 의존성 해결

**1,2를 혼합하여 생성할때는 1, 변경할때는 2를 하면 좋다.**

(시스템의 상태를 안정적으로 유지하고 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가장 선호되는 방법)

# ✅ 유연한 설계

> 설계를 유연하고 재사용 가능하게 만들기로 결정했다면 의존성을 관리하는 데 유용한 몇 가지 원칙과 기법을 익힐 필요가 있다.

## 의존성과 결합도

객체들이 협력하기 위해서는 서로의 존대와 수행 가능한 책임을 알아야 한다.

의존성은 객체들의 협력을 가능하게 만드는 매개체라는 관점에서는 바람직하다.

**문제는 의존성의 존재가 아니라 의존성의 정도다.**

바람직한 의존성은 **재사용성**과 관련이 있다. 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.

바람직하지 않은 의존성 : 다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성이다.

의존성이 바람직할 때 느슨한 결합도라고 하고 바람직하지 못할 때 단단한 결합도라고 한다.

## 지식이 결합을 낳는다

결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.

더 많이 알고 있다는 것은 더 적은 컨텍서트에서 재사용 가능하다는 것을 의미한다.

이 목적을 달성할 수 있는 가장 효과적인 방법에 대해 이미 알고 있다는 것.

**바로 추상화가 그것이다.**

## 추상화에 의존하라

추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.

**의존 대상 구분**

- 구체 클래스 의존성
- 추상 클래스의존성
  - 여전히 클라이언트는 협력 대상의 클래스 상속 계층을 알고 있어야 한다.
- 인터페이스 의존성
  - 인터페이스에 의존하는 것이 더 효과적이다. 결합도가 낮아진다.

## new는 해롭다

new를 잘못 사용하면 결합도가 극단적으로 높아진다.

**해로운 이유**

- 구체 클래스에 의존해 결합도가 높아진다.
- 어떤 인자를 이용할지 알아야 하기 때문에 결합도가 높아진다.

## 가끔은 생성해도 무방하다

대부분의 경우 협력하는 객체가 정해져있고 가끔 다른 객체와 협력한다고 하면 아래처럼 생성해도 괜찮다.

```java
class Movie {
	public Movie( ... ) {
    	this( ... , new AmountDiscountPolicy( ... ));
    }

	public Movie( ... , DiscountPolicy discountPolicy) {
    	...
    	this.DiscountPolicy = discountPolicy;
    }
}
```

## 조합 가능한 행동

훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다.

# 09. 유연한 설계

## 개방-폐쇄 원칙

> 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

확장과 수정은 각각 동작과 코드의 관점을 반영한다.

- 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타입 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조
- 이 원칙의 핵심은 추상화에 의존하는 것
  - 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게되므로 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.

<aside>
💡 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들 수 있는 것은 아니다. 개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다.

</aside>

## 생성 사용 분리

유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.

### Factory 추가하기

생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 `FACTORY`라고 부른다.

### 순수한 가공물에게 책임 할당하기

`FACTORY`를 추가한 이유는 순수하게 기술적인 결정이다.

결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을 가공의 객체로 이동시킨 것.

**객체를 분해하는 두 가지 방식**

- 표현적 분해
  - 객체들을 이용해 시스템을 분해. 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.
- 행위적 분해
  - 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체를 **PURE FABRICATION**이라고 부른다.
  - 이는 보통 특정한 행동을 표현하는 것이 일반적이라 행위적 분해에 의해 생성된다.

<aside>
💡 이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다. 객체지향 애플리케이션은 도메인 개념뿐만 아니라 설계자들이 임의적으로 창조한 인공적인 추상화들을 포함하고 있다.

</aside>

## 의존성 주입

> 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입이라고 한다.

**의존성을 해결하는 세 가지 방법**

- 생성자 주입
- setter 주입
- 메서드 주입

### 숨겨진 의존성은 나쁘다.

**SERVICE LOCATOR패턴**의 가장 큰 단점은 의존성을 감춘다는 것.

- 문제점을 코드 작성이 아니라 실행 시점으로 미룬다.
- 모든 단위 테스트 케이스가 같은 상태를 공유하게 된다. 단위테스트는 서로 고립돼야 한다는 기본 원칙을 위반한다.

문제의 원인은 숨겨진 의존성이 캡슐화를 위반헀기 때문이다.

→ 코드의 내부 구현을 이해할 것을 강요한다.

<aside>
💡 명시적인 의존성이 숨겨진 의존성보다 좋다.

</aside>

## 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다.

복잡성이 필요한 이유와 합리적인 근거를 제시하지 않는다면 어느 누구도 설계를 만족스러운 해법으로 받아들이지 않을 것이다.

### 협력과 책임이 중요하다.

설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력에 초점을 맞춰야 한다.

초보자가 자주 저지르는 실수 중 하나는 객체의 역할과 책임이 자리를 잡기 전에 너무 성급하게 객체 생성에 집중하는 것.

객체를 생성할 책임을 담당할 객체나 객체 생성 메커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미뤄야만 한다.

> 객체가 무엇이 되고 싶은지를 알게 될 때까지 객체들을 어떻게 인스턴스화 할 것인지에 대해 전혀 신경 쓰지 않았다는 것이다.
> 가장 중요한 관심거리는 마치 객체자 이미 존재하는 것처럼 이들 간의 관계를 신경 쓰는 일이다.

## 느낀점

어떤 의존성이 나쁜지 그리고 어떤 의존성이 좋은지를 알 수 있어서 좋았다.
의존성을 어떻게 관리하는지를 알아보고 이를 바탕으로 유연한 설계를 알아봐서 이해가 더 잘됐다.
OCP, DIP에 대해 더 알아볼 수 있어서 좋았다.
**가끔은 생성해도 무방하다** 에서 사용한 방식이 신선했다.
9장 마지막 말처럼 객체의 생성보다 객체가 해야하는 것과 역할에 집중하는 것이 유연한 설계에 가까워진다는 것을 꺠달았다.

# 06. 메시지와 인터페이스

## 협력과 메시지

- 객체는 협력에 참여하는 동안 클라이언트와 서버 역할을 동시에 수행하는 것이 일반적이다.
- 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다.
- 메시지 : 오퍼레이션명 + 인자
- 전통적인 방식의 함수 호출과 프로시저 호출은 다르다.
  - 전통적인 방식 : 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로시저 호출 구문을 작성한다. 코드의 의미가 컴파일 시점과 실행 시점에 동일하다는 것
  - 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
- 실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있다.
- 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다.

## 인터페이스와 설계 품질

- 책임 주도 설계 방법을 따르면 추상적인 인터페이스를 설계할 수 있다.
  - 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다.

### 디미터 법칙

객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.

협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다.

- M의 인자로 전달된 클래스
- C의 인스턴스 변수의 클래스

불필요한 어떤 것도 다른 객체에게 보여주지 않으며 (⇒ 캡슐화) 다른 객체의 구현에 의존하지 않는 코드를 작성할 수 있다.

하지만 무조건 적용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다.

### 묻지 말고 시켜라

:디미터 법칙의 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어

- 객체의 상태에 대해 묻지 말고 원하는 것을 시킨다.
- 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 동일한 클래스 안에 두게 된다.
- 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법을 없었는지 고민해봐라.
- 이 원칙은 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 힌트를 제공한다.

### 의도를 드러내는 인터페이스

**메서드 명명법 - 켄트 백**

1. 메시지가 작업을 어떻게 수행하는지를 나타내도록 짓기
   1. 메서드 구현 방법이 드러나므로 좋지 않음, 캡슐화 위반
2. ‘어떻게’가 아니라 ‘무엇’을 하는지를 드러내게 하기
   1. 코드를 읽기 쉽게 하고 유연하게 함.
   2. 클라이언트의 관점에서 동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.
      → Intention Revealing Selector

## 원칙의 함정

> 소프트웨어 설계에 법칙이란 존재하지 않는다. 법칙에는 예외가 없지만 원칙에는 예외가 넘쳐난다.

초보자는 원칙을 맹목적으로 추종한다. 심지어 적용하려는 원칙들이 서로 충돌하는 경우에도 원칙에 정당성을 부여하고 억지로 끼워 맞추려고 노력한다.

### 결합도와 응집도의 충돌

클래스는 하나의 변경 원인만을 가져야 한다. 책임들이 함께 뭉쳐있는 클래스는 작은 변경으로도 쉽게 무너진다. 따라서 디미터 법칙과 묻지말고 시켜라 원칙을 무작성 따르면 애플리케이션은 응집도가 낮은 객체로 넘쳐날 것이다.

할인 여부를 판단하는 코드를 어디에 두어야 할까?

`Screening` 에 두면 `Screening` 이 기간에 따른 할인 조건을 판단하는 책임을 안게 된다.

`Screening` 이 담당하는 본질적인 책임은 영화를 예매하는 것이며 이렇게 되면 객체의 응집도가 낮아진다.

`PeriodCondition` 은 할인 조건을 판단하는 책임이 본질적이다.

따라서 `Screening` 의 캡술화를 향상시키는 것보다 `Screening` 의 응집도를 높이고 `Screening` 과 `PeriodCondition` 사이의 결합도를 낮추는 것이 전체적인 관점에서 더 좋은 방법이다.

설계는 트레이드오프의 산물이다. 소프트웨어 설계에 존재하는 몇 안되는 법칙 중 하나는 “경우에 따라 다르다”라는 사실을 명심하라.

## 명령-쿼리 분리 원칙

명령과 쿼리를 분리하기 위해서는 다음의 두가지 규칙을 준수해야 한다.

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

이런 스타일을 사용하면 객체의 캡슐화와 다양한 문맥에의 재사용을 보장할 수 있다.

명령과 쿼리를 섞으면 실행 결과를 예측하기가 어려워질 수 있다.

겉으로 보기엔 쿼리처럼 보이지만 내부적으로 부수효과를 가지는 메서드는 이해하기 어렵고, 잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다.

## 책임에 초점을 맞춰라

설명한 모든 방식의 중심에는 객체가 수행할 책임이 위치한다.

훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계 원칙을 따르는 것이다.

## 느낀점

디미터 법칙에 대해 자세히 알 수 있어서 좋았다. 클린코드에서 봤을 때 보다 이해가 잘 갔다.

또한 디미터 법칙을 맹신하면 안되는 이유도 알 수 있어서 좋았다.

소프트웨어에서는 법칙이 없고 원칙이 있으며 원칙에는 예외가 넘쳐난다라는 말이 인상깊었다.

다양한 책을 읽으면서 공부하고 있지만 해당 책을 읽을때마다 그 책이 말하고자하는 방식에 더 치중되는 것 같다. 이 책이 말하는 것처럼 원칙을 맹목적으로 따르지 않으려고 노력해야 할 것 같다.

책임을 중심으로 설계를 하는 것에 집중하고 트레이드 오프를 이해하면 도움이 될 것 같다.

# 07. 객체 분해

조지 밀러의 이론에 따르면 사람이 동시에 단기 기억 안에 저장할 수 있는 정보의 개수는 9개 정도를 넘지 못한다고 한다.

프로그램은 시간과 공간의 트레이드오프를 통해 효율을 향상시킬 수 있지만, 사람의 단기 기억에 있어 시간과 공간의 두 측면 모두가 병목지점으로 작용한다.

본질적인 정보만 남기는 추상화를 통해 단기 기억의 한계를 초월할 수 있다.

이런 추상화는 인류가 소프트웨어 개발 영역에 사용해 왔다.

## 프로시저 추상화와 데이터 추상화

현대적인 프로그래밍 언어를 특징 짓는 중요한 두 가지 추상화 매커니즘은 **프로시저 추상화**와 **데이터 추상화**다.

데이터 추상화를 할 때 데이터를 중심으로 타입을 추상화 하는 것을 **추상 데이터 타입**이라고 하고 , 데이터를 중심으로 프로시저를 추상화하는 것을 **객체지향**이라고 한다.

## 프로시저 추상화와 기능 분해

전통적인 기능 분해 방법인 하향식 접근법은 변경에 취약한 설계를 낳는다.

시스템이 하나의 메인 함수로만 구현된다는 개념은 현대적인 상호작용 시스템을 개발하는 데 적합하지 않다.

또한 하향식 접근법은 기능을 분해하는 과정에서 사용자 인터페이스의 관심사와 비지니스 로직의 관심사를 동시에 고려하도록 강요하기 때문에 “관심사의 분리”라는 아키텍처 설계의 목적을 달성하기 어렵다.

하향식 설계와 관련된 모든 문제의 원인은 결합도다. 상위 함수가 강요하는 문맥에 강하게 결합된다.

## 모듈

데이비드 파나스는 소프트웨어 개발의 가장 중요한 원리인 동시에 가장 많은 오해를 받고 있는 **정보 은닉**의 개념을 소개했다.

정보 은닉은 시스템을 모듈 단위로 분해하기 위한 기본 원리로 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것이 핵심이다.

**기능 분해**가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 것이라면

**모듈 분해**는 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다.

### 모듈의 장점과 한계

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
- 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.

비록 모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만 태생적으로 변경을 관리하기 위한 구현 기법이기 때문에 추상화 관점에서의 한계점이 명확하다.

## 데이터 추상화와 추상 데이터 타입

프로시저 추상화를 보완하기 위해 데이터 추상화의 개념을 제안했다.

추상 데이터 타입을 구현하려면 프로그래밍 언어의 지원이 필요하다.

- 타입 정의를 선언할 수 있어야 한다.
- 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
- 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
- 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

## 클래스

### 클래스는 추상 데이터 타입인가?

추상 데이터 타입과 클래스는 동일하지 않다.

클래스는 상속과 다형성을 지원하는 데 비해 추상 데이터 타입은 지원하지 못한다.

상속과 다형성을 지원하는 객체지향 프로그래밍과 구분하기 위해 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임을 객체기반 프로그래밍이라고 부르기도 한다.

### 변경을 기준으로 선택하라

단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지는 않는다.

타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다.

클래스가 추상 테이터 타입의 개념을 따르는지를 확인할 수 있는 가장 간단한 방법은 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지를 살펴보는 것이다.

인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주된다.

**객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다.**

기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 개방-폐쇄 원칙이라고 부른다.

새로운 타입을 빈번하게 추가해야 한다면 객체지향의 클래스 구조가 더 유용하다.

새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상 데이터 타입을 선택하는 것이 현명하다.

변경의 축을 찾아라. 객체지향적인 접근법이 모든 경우에 올바른 해결 방법인 것은 아니다.

### 협력이 중요하다

객체지향은 기능을 수행하기 위해 객체들이 협력하는 방식에 집중한다. 협력이라는 문맥을 고려하지 않고 오퍼레이션의 구현 방식을 타입별로 분배하면 안된다.

객체를 설계할 때는 책임 주도 설계의 흐름을 따라야 한다.

타입계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며 그 자체가 목적이 되어서는 안된다.

## 느낀점

“객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다. “라는 말이 인상깊었다.

그렇다고 이렇게 타입을 중심으로 클래스 계층에 오퍼레션의 구현을 분배하는 것이 객체지향 설계가 아니라, 역할, 책임, 협력을 중심으로 접근해야 객체지향 설계라는 것을 배웠다.

프로시저 추상화와 데이터 추상화에 대한 설명이 추상화와 객체지향에 대해서 더 깊이있게 이해할 수 있게 했다.

내가 했던 설계 방법이 하향식 접근법과 비슷했던 것 같다. 객체지향설계를 할 수 있게 노력해야되겠다.

# 10장 상속과 코드 재사용

중복 코드 제거, 코드 재사용 하면 가장 먼저 떠오르는것이 상속이다. 하지만 상속을 맹목적으로 사용하면 오히려 변경에 취약한 코드가 만들어진다.

이 장에선 상속을 사용할때의 주의점, 사용하면서 더 잘 사용하는 방법과 그럼에도 불구하고 상속은 단점이 많다는 내용을 포함하고 있다.

아래는 이 책에서 상속을 사용할 때 경고하는 내용들이다.

## 상속 사용시 주의점

**📌 super 호출에 대한 치명적인 단점**

자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스를 직접 호출할 경우 두 클래스는 강하게 결합된다.<br/>
super 사용을 자제하자.

**📌 부모 클래스의 메서드가 자식 클래스의 내부 구조 규칙을 깨트릴 수 있다.**

부모 클래스 변경에 의해 자식 클래스가 영향 받는 것을 `취약한 기반 클래스 문제`라고 한다.

두가지 예가 있다:
- Vetor를 상속받은 Stack
  - 요소의 추가, 삭제 오퍼레이션제공하는 Vector를 재사용 하기 위해 Stack을 Vector의 자식 클래스로 구현했다.
  - Stack의 스팩에선 요소의 마지막 위치에서만 추가/삭제가 가능하지만, Vector의 퍼블릭 인터페이스로 임의의 위치의 수정이 가능해진다.
- Hashtable을 상속받은 Properties
  - Properties는 String만 넣을 수 있지만, Hashtable은 String이 아니여도 된다.

**📌 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우, 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.**

자식클래스가 부모 클래스의 메서드를 오버라이딩 할 때, 부모클래스의 내부 구현 내용을 알아야 문제가 없는 경우가 생긴다.

하지만 이는 캡슐화는 위반하는 내용이다.

코드 재사용을 위해 상속을 함으로써 객체지향의 캡슐화를 희생하는 순간이다.

**📌 중복 코드는 부모 클래스로!**

자식 클래스들의 공통점을 추상클래스 같은 부모 클래스로 옮겨 코드 재사용성도 높이면서, 추상화에 의존하는 설계를 할 수 있다.

같은 변경의 이유를 가진 부분을 부모클래스로 올리자.

-> 이토록 상속은 재사용성을 높이지만, 주의할 점이 많다. **합성** 을 이용하면, 이를 해결할 수 있다.

## 11장 합성과 유연한 설계

**📌 훅 메서드**

오버라이드 할 목적으로 추상 메서드를 제공하면 상속받는 모든 클래스가 메서드를 오버라이드 해야 한다.

그 메서드의 내용이 간단하고 중복될경우 기본 구현을 제공하는 방식으로 문제점을 해결할 수 있다.

**📌 클래스 폭발!**

하나의 기능을 추가하려면 클래스를 추가해 상속 구조에 끼워넣는 상황이 계속해서 발생하면, 클래스가 너무 많아지는 현상이 생긴다.

이를 합성으로 해결할 수 있다.

**📌 런타임에 결정되는 합성**

상속관계는 컴파일타임에 결정되지만, 합성관계를 런타임에 결정된다. 앞서 8장에서 강조한 내용처럼, 컴파일타임 의존성과 런타임 의존성이 멀수록 설계가 유연해진다.

# 느낀점

객체지향 하면 상속이 가장 먼저 떠오르지만, 이를 남발하면 유지보수에 치명적일 수 있고, 코드 구현 당시의 의도와는 다른 결과를 초래할 수 있다는 점을 예시와 함께 공부할 수 있었다.

합성을 이용하는 방식을 의도적으로 사용해야겠다는 생각을 했다.

말미의 믹스인은 사실 잘 이해가 되진 않았다.. 스칼라가 이렇게까지 새로운 개념이 적용된 언어인줄은 몰랐는데, 나중에 언젠가 공부해보면 좋을 것 같다는 생각을 했다.

책을 읽으면서 100% 이해는 못하지만,, 그래도 이것저것 적용해보면서 더 나은 설계를 하는 나 자신을 발견하는 요즘인데, 매우 뿌듯하다 :)

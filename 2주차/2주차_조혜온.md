# 02. 객체지향 프로그래밍

# 영화 예매 시스템

특정한 조건을 만족하는 예매자는 요금을 할인 받을 수 있다.

![image](https://github.com/Wake-up-together-TogetUp/togetup-server/assets/68319395/6eeab572-33e7-4b25-8a52-244e7e1bbfef)

# 객체지향 프로그래밍을 향해

객체지향 프로그램을 작성할 때 어떤 클래스가 필요한지를 고민하는 것은 객체지향의 본질과 거리가 있다. 클래스가 아닌 객체에 초점을 맞추어 어떤 객체가 필요할지 고민해야 한다. 그리고 객체를 독립적인 존재가 아니라 기능을 구현하기 위한 협력적인 존재로 보아야 한다.

### 자율적인 객체

클래스를 구현할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 일이다.

캡슐화와 접근 제어는 객체를 **퍼블릭 인터페이스(외부에서 접근 가능)**와 **구현(내부에서만 접근 가능)**으로 나눈다.

**인터페이스와 구현의 분리 원칙**은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

### 프로그래머의 자유

클래스 작성자 : 새로운 데이터 타입을 프로그램에 추가한다.

클라이언트 프로그래머 : 클래스 작성자가 추가한 데이터 타입을 사용한다.

**접근 제어 메커니즘**은 내부와 외부를 명확히 경계 짓고 **클래스 작성자**가 **내부 구현**을 **은닉**할 수 있게 해준다.

구현 은닉을 통해 클라이언트 프로그래머는 인터페이스만 알고 있어도 클래스를 사용할 수 있고, 클래스 작성자는 인터페이스를 바꾸지 않는 한 내부 구현을 자유롭게 수정할 수 있다.

**따라서 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.**

# 할인 요금 구하기

DiscountPolicy를 상속받는 AmountDiscountPolicy, PercentDiscountPolicy

- 실제로 할인 요금을 계산하는 것은 getDiscountAmount를 오버라이딩한 자식클래스의 메서드
  ⇒ 부모클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위인하는 디자인 패턴을 **TEMPLATE METHOD 패턴** 이라 한다.

```java
public abstract class DiscountPolicy {
//할인 정책은 여러 개의 할인 조건을 포함할 수 있다.
    private List<DiscountCondition> conditions = new ArrayList<>();

//여러개의 할인 조건을 받을 수 있게 만들어진 생성자
//생성자 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진
//객체의 생성을 보장할 수 있다.
    public DiscountPolicy(DiscountCondition ... conditions) {
        this.conditions = Arrays.asList(conditions);
    }

    public Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }

        return Money.ZERO;
    }

    abstract protected Money getDiscountAmount(Screening Screening);
}
```

# 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

코드의 의존성과 실행 시점의 의존성이 서로 다를 수 있다.

→ 클래스 사이의의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.

**설계는 트레이드오프의 산물이다.**

코드의 의존성과 실행 시점의 의존성이 다르면 다를수록

→ 코드를 이해하기 어려워진다.

→ 유연해지고 확장 가능해진다.

훌륭한 객체지향 설계자로 성장하기 위해서는 유연성과 가독성 사이에서 고민해야 한다.

### 차이에 의한 프로그래밍

상속을 통해 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있다.

부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을

**차이에 의한 프로그래밍**이라고 부른다.

### 상속과 인터페이스

자식 클래스는 부모클래스 대신에 사용될 수 있다.

자식 클래스가 부모 클래스르 ㄹ대신하는 것을 업캐스팅이라고 한다.

### 다형성

메시지와 메서드는 다른 개념이다.

Movie는 `DiscountPolicy`의 `calculateDiscountAmount` 에게 메시지를 전송하면 ,

`AmountDiscountPolicy` or `PercentDiscountPolicy` 에서 오버라이딩한 메서드가 실행된다.

Movie는 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.

→ **다형성**이란 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력

메시지와 메서드를 실행 시점에 바인딩 하는 것을 **지연 바인딩** or **동적 바인딩**이라고한다.

# 추상화와 유연성

추상화를 사용할 경우 장점

- 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
  ex) 영화 예매 요금은 최대 하나의 할인 정책과 다수의 할인 조건을 이용해 계산할 수 있다.

추상화를 이용해 정의한 상위의 협력 흐름을 따르는 개념은 중요하다.

재사용 가능한 설계의 기본을 이루는 **디자인 패턴, 프레임워크**에서 이러한 객체지향의 매커니즘을 활용하기 때문이다.

![image](https://github.com/Wake-up-together-TogetUp/togetup-server/assets/68319395/5b613425-a76c-4710-95e8-daa193152899)

### 유연한 설계

책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분의 경우 좋지 않은 선택이다. 예외 케이스를 최소화하고 일관성을 유지할 수 있는 방법을 선택하라

영화 정책이 없을 때 할인 금액이 0원이라는사실을 결정하는 책임을 그대로 `DiscountPolicy`에 위치하게 하려면 `NoneDiscountPolicy`라는 새로운 클래스를 추가하면 된다.

추상화를 통해 설계 했기 때문에 Movie와 DiscountPolicy를 수정하지 않고 기능을 확장할 수 있다.

### 추상 클래스와 인터페이스 트레이드 오프

앞서 나왔던 코드를 보면 `NoneDiscountPolicy` 의 메서드가 어떤 값을 반환하던 상관이 없다.

애초에 할인조건이 없을 경우 메서드를 호출하지 않기 때문이다.

하지만 이것은 부모클래스와 `NoneDiscountPolicy` 를 개념적으로 결합시킨다.

조건이 없을 경우 DiscountPolicy가 0을 반환할 것을 가정하기 때문에.

```java
public Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : conditions) {
            **if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);**
            }
        }

        return Money.ZERO;
    }
```

해결방법

이렇게 구조를 바꾼다.

- DiscountPolicy클래스를 인터페이스로 바꾼다.

![image](https://github.com/Wake-up-together-TogetUp/togetup-server/assets/68319395/bc90326c-5c09-43a7-99d5-fa9e06c3dc3d)

개념적인 혼란과 결합을 제거할 수 있다.

이런 설계가 현실적으로 과하다는 생각이 들 수도 있다.

구현과 관련된 모든 것들이 트레이드오프의 대상이다.

작성하는 모든 코드에 합당한 이유가 있어야 한다.

트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.

## 코드의 재사용

상속보다는 합성이 더 좋은 방법이라는 이야기가 많다.

### 상속

- 캡슐화 위반
- 유연하지 못한 설계

### 합성

- 다른 객체(B)를 자신(A)의 인스턴스 변수로 포함
  - A는 B의내부 구현을 모른다.
- 인터페이스를 통해 약한 결합

**객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해
협력에 참여하는 객체들 사이의 상호작용**

## 느낀 점

설계를 할 때 트레이드오프에 대해 고민을 많이 해야겠다고 느꼈다.

처음 설계를 할 때 클래스를 구현하는 것보다 ,객체에 초점을 맞추고 객체 사이의 상호작용에 집중을 해야겠다고 느꼈다.  
</br>
</br>

# 03. 역할, 책임, 협력

객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력이다.

애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한 지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경하기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.

# 협력

협력은 객체지향의 세계에서 가능을 구현할 수 있는 유일한 방법이다.

두 객체 사이의 협력은 하나의 객체가 다른 객체에게 도움을 요청할 때 시작된다.

객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다.

객체의 협력이 행동을 결정하고, 행동이 상태를 결정한다.

# 책임

책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대해 개략적으로 서술한 문장이다.

크게 ‘하는 것’과 ‘아는 것’의 두 가지 범주로 나누어 세분화하고 있다.

책임은 객체지향 설계의 핵심이다.

### 책임 할당

자율적인 객체를 만드는 가장 기본적인 방법은 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당하는 것이다. 이를 정보 전문가 패턴이라고 부른다.

ex)

“예매하라” 메시지를 처리할 적절한 객체는 영화 예매와 관련된 정보를 가장 많이 알고 있는 전문가인 Screening에게 할당하는 것이 바람직하다.

### 책임 주도 설계

어떤 책임을 선택하고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법을 **책임 주도 설계**라고 부른다.

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 잇는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

**책임을 할당할 때 고려할 요소**

1. 메시지가 객체를 결정한다.
   1. 객체가 최소한의 인터페이스를 가질 수 있게 된다.
   2. 충분히 추상적인 인터페이스를 가질 수 있게 된다.
2. 행동이 상태를 결정한다.
   1. 객체는 협력에 필요한 행동을 제공해야 한다.
   2. 행동이 아니라 상태에 초점을 맞춰 구현하면 캡슐화를 저해하게 된다.
      그러지 않기 위해서는 협력이라는 문맥 안에서 객체를 생각해야 한다.

# 역할

역할은 다른 것으로 교체할 수 있는 책임의 집합이다.

객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.

협업을 모델링할 때는 특정한 객체가 아니라 역할에게 책임을 할당한다고 생각하는 게 좋다.

**유연하고 재사용 가능한 협력**

역할이 중요한 이유는 역할을 통해 유연하고 재사용 가능한 협력을 얻을 수 있기 때문이다.

ex)

영화 예매 도메인에서 금액 할인 정책, 비율 할인 정책이 존재하기 때문에

`AmountDiscountPolicy`, `PercentDiscountPolicy` 두 종류의 객체가 “할인 요금을 계산하라”

라는 메시지에 응답할 수 있어야한다.

두 종류의 객체가 참여하는 협력을 개별적으로 만든다면 대부분의 코드가 중복되고, 중복은 모든 문제의 근원이기 때문에 이런 방법은 피해야 한다.

문제를 해결하기 위해서는
객체가 아닌 책임에 초점을 맞춰, 두 객체가 동일한 책임을 수행한다는 사실을 알고 두 협력을 하나로 통합할 수 있다.

추상클래스, 인터페이스 등을 통해 역할을 구현할 수 있다.

## 객체 대 역할

한 종류의 객체만 협력에 참여하는 상황에서 역할이라는 개념을 고려하는 것이 유용할까?

협력에 참여하는 대상을 객체가 한 종류라면 객체라고 생각하고, 객체가 여러 종류라면 역할이라고 생각하면 된다.

설계초반에 이런 결정을 하는 것이 어려울 수 있다. 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표이고 역할과 객체를 명확하게 구분하는 것은 그렇게 중요하지 않다. 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이 가장 좋은 방법이다.

## 역할과 추상화

추상화를 이용한 설계를 하면

1. 추상화 계층만을 이용하면 중요한 정책을 상위 수준에서 단순화할 수 있다.
2. 설계가 좀 더 유연해진다.

라는 장점이 있다.

역할은 객체의 종류를 숨기기 때문에 이런 관점에서 역할을 객체의 추상화라고 볼 수 있다.

상위 수준에서 협력을 설명하면 구체적인 객체들이 가지는 복잡성을 제거하고 단순화해서 표현할 수 있다. 또한 역할이 다양한 종류의 객체를 끼워 넣을 수 있는 슬롯이라는 점에서 동일한 역할을 수행하는 객체들은 서로 대체 가능하다.

**느낀 점**

역할과 책임에 대해서 각각 자세히 살펴봄으로 써 각각의 특징과 정의를 알 수 있어서 좋았다.

역할, 책임이 중요한 개념인 것은 알고 있었지만 둘에 대해 깊이 알지 못해 비슷한 개념으로 생각하고 있었던 것 같다.

특히 역할과 추상화 부분이 인상 깊었다. 역할을 슬롯이라고 생각하고 객체를 끼워 넣는 다는 개념이 신기했다. 책에서 말한 것처럼 이렇게 하면 유연한 설계가 가능하고, 서비스의 흐름을 상위 수준에서 설명할 수 있어서 세부 사항에 얽매이지 않고 설계할 수 있을 것 같다. 그래서 다음에 프로젝트를 할 때 역할에 대해서 생각하고 설계를 하면 좋을 것 같다는 생각을 했다.
